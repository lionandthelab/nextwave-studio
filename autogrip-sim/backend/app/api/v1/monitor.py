"""Real-time monitoring endpoints with Server-Sent Events."""

from __future__ import annotations

import asyncio
import json
import logging
import re
import time

from fastapi import APIRouter, HTTPException
from fastapi.responses import FileResponse
from sse_starlette.sse import EventSourceResponse

from app.config import settings
from app.session_manager import session_manager

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/monitor", tags=["monitor"])

# M5: Maximum SSE connection duration in seconds to prevent zombie connections
MAX_SSE_DURATION = 3600

_SESSION_ID_RE = re.compile(r"^[a-f0-9]{32}$")


def _validate_session_id(session_id: str) -> None:
    """Validate that session_id is a valid hex UUID to prevent path traversal."""
    if not _SESSION_ID_RE.match(session_id):
        raise HTTPException(
            status_code=400, detail="Invalid session ID format"
        )


async def _event_generator(session_id: str):
    """Yield SSE events as the correction loop progresses."""
    last_log_index = 0
    last_iteration = 0
    last_code = None
    start_time = time.monotonic()

    while True:
        # M5: Close the SSE connection after MAX_SSE_DURATION seconds
        elapsed = time.monotonic() - start_time
        if elapsed > MAX_SSE_DURATION:
            yield {
                "event": "timeout",
                "data": json.dumps({
                    "message": f"SSE connection closed after {MAX_SSE_DURATION}s",
                }),
            }
            return

        session = await session_manager.get_session(session_id)
        if session is None:
            yield {
                "event": "error",
                "data": json.dumps({"message": "Session not found"}),
            }
            return

        # Emit new log entries
        logs = await session_manager.get_logs(session_id)
        for entry in logs[last_log_index:]:
            yield {
                "event": "log",
                "data": json.dumps(entry),
            }
        last_log_index = len(logs)

        # Emit iteration updates
        if session.current_iteration > last_iteration:
            # Emit iteration_start for the new iteration
            yield {
                "event": "iteration_start",
                "data": json.dumps({"iteration": session.current_iteration}),
            }

            # Emit any new results as iteration_result events
            for result in session.results[last_iteration:]:
                yield {
                    "event": "iteration_result",
                    "data": result.model_dump_json(),
                }
            last_iteration = session.current_iteration

        # Emit code_update when generated code changes
        if session.generated_code and session.generated_code != last_code:
            last_code = session.generated_code
            yield {
                "event": "code_update",
                "data": json.dumps({"code": session.generated_code}),
            }

        # Emit terminal states as "complete" (frontend expects this event name)
        if session.status in ("success", "failed", "stopped"):
            status = await session_manager.get_loop_status(session_id)
            gif_url = f"/api/v1/monitor/result/{session_id}/gif"
            yield {
                "event": "complete",
                "data": json.dumps({
                    "status": session.status,
                    "gif_url": gif_url,
                    "code": session.generated_code,
                    **(status.model_dump() if status else {}),
                }),
            }
            return

        await asyncio.sleep(0.5)


@router.get("/stream/{session_id}")
async def stream_events(session_id: str) -> EventSourceResponse:
    """SSE stream that pushes simulation logs and status updates."""
    _validate_session_id(session_id)
    session = await session_manager.get_session(session_id)
    if session is None:
        raise HTTPException(status_code=404, detail="Session not found")

    return EventSourceResponse(_event_generator(session_id))


@router.get("/logs/{session_id}")
async def get_logs(session_id: str) -> list[dict]:
    """Return the full log history for a session."""
    _validate_session_id(session_id)
    session = await session_manager.get_session(session_id)
    if session is None:
        raise HTTPException(status_code=404, detail="Session not found")
    return await session_manager.get_logs(session_id)


@router.get("/result/{session_id}/gif")
async def get_result_gif(session_id: str) -> FileResponse:
    """Serve the result GIF generated by the simulation, if available."""
    _validate_session_id(session_id)
    session = await session_manager.get_session(session_id)
    if session is None:
        raise HTTPException(status_code=404, detail="Session not found")

    gif_path = (settings.results_path / f"{session_id}_result.gif").resolve()
    if not str(gif_path).startswith(str(settings.results_path.resolve())):
        raise HTTPException(status_code=400, detail="Invalid path")
    if not gif_path.is_file():
        raise HTTPException(
            status_code=404, detail="Result GIF not yet available"
        )

    return FileResponse(
        path=str(gif_path),
        media_type="image/gif",
        filename=f"{session_id}_result.gif",
    )
